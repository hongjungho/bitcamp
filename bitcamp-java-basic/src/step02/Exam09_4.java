// 배열 - 배열 레퍼런스와 배열 인스턴스의 관계
package step02;

public class Exam09_4 {
    public static void main(String[] args) {
        int[] arr1;
        arr1 = new int[]{100,200,300};

        System.out.println(arr1[0]);
        System.out.println(arr1[1]);
        System.out.println(arr1[2]);
        // 새로운 int 배열을 확보하여 arr1 레퍼런스에 그주소를 저장한다.
        // => arr1 변수에는 새 배열의 주소가 저장된다
        // => 그러면 이전 배열의 주소는 잃어 버린다ㅣ
        // => 주소를 잃어 버린 배열은 

        arr1 = new int[]{10,20,30,40,50};
        System.out.println(arr1[0]);
        System.out.println(arr1[1]);
        System.out.println(arr1[2]);
    }
}

// 가비지 (garbage) 란?
// - 주소를 잃어버려 사용할수 없는 메모리 인스턴스
// - JVM을 종료하면 어차피 OS에게 사용한 메모리를 반납해야 하기때문에
//...자동으로 해제된다.
// - 그러나 JVM이 실행하는 중에 개발자가 임의로 해제할 수 없다.
// - 오직 가비지 컬렉터만이 가비지를 해제할수 있다.
//
// 가비지 컬렉터 (garbage collector)?
// - 인스턴스의 주소를 알고 있는 변수가 없을 경우
//...그 인스턴스는 가비지로 간주된다.
// - 가비지 메모리를 재사용할 수 있도록 해제시키는 방법
//...=> 개발자가 임의로 해제 불가능 하다
//...=> 다음의 경우에 가비지 컬렉터가 실행되어 가비지들이 해제된다.
// 1) 메모리가 부족할 경우
//......- OS에게 메모리를 요청하기 전에 먼저 가비지를 청소한 다음에
//.........요청할지 말지 정한다
// 2) cpu가 한가할 때
//....24시간 , 365일 내내 멈춤없이 JVM이 실행될 경우,
//....CPU가 한가한 시간에 가비지를 청소 할수 있다.
//...-정확히 언제인지 시간을 지정하거나 예측할 수는 없다.
// 3) 개발자가 가비지 컬렉터를 실행하라고 명령을 내릴때.
//....- 명령을 내린다고 즉시 실행 되는것은 아니다.
//....- 일종의 가비지 실행을 예약하는 것이다.
// 결론!
// - 가비지는 가비지 컬렉터가 자기 나름의 조건에 따라 실행할것 이니
//...개발자는 신경쓰지 말라!
// - 만약 메모리를 개발자가 마음대로 조작하고싶으면,
//...C / C++ 로 프로그래밍해라s